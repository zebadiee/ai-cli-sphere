"""
ECIR Authority Contracts

This module defines the authority boundaries and contracts for the ECIR system.
These contracts MUST be enforced throughout the system to maintain compliance and audit trails.

DO NOT MODIFY THIS FILE - it defines the authority layer.
"""

from enum import Enum
from typing import Dict, List, Set


class ClassificationCode(Enum):
    """
    Classification codes for EICR observations.
    MUST be assigned by qualified human inspector ONLY.
    """
    C1 = "C1"  # Danger present - immediate remedial action required
    C2 = "C2"  # Potentially dangerous - urgent remedial action required
    C3 = "C3"  # Improvement recommended
    FI = "FI"  # Further investigation required


class OverallAssessment(Enum):
    """
    Overall assessment of the installation.
    MUST be determined by qualified human inspector ONLY.
    """
    SATISFACTORY = "SATISFACTORY"
    UNSATISFACTORY = "UNSATISFACTORY"


class AuthorityBoundary:
    """
    Defines what the system CAN and CANNOT do autonomously.
    """
    
    # Fields that REQUIRE human assertion
    HUMAN_REQUIRED_FIELDS: Set[str] = {
        "overall_assessment",
        "classification",
        "signature",
        "inspector_name",
        "date_of_inspection",
    }
    
    # Codes that CANNOT be auto-assigned
    PROTECTED_CODES: Set[str] = {"C1", "C2", "C3", "FI"}
    
    # Fields that CANNOT be AI-generated
    NO_AI_GENERATION: Set[str] = {
        "observations.description",
        "recommendations.description",
        "general_condition",
    }
    
    # Evidence handling rules
    EVIDENCE_RULES: Dict[str, str] = {
        "mode": "reference_only",
        "embedding": "prohibited",
        "storage": "external_nice_system",
        "linking": "by_id_only",
    }
    
    @staticmethod
    def validate_human_assertion(field_name: str, value: any) -> bool:
        """
        Validate that a field requiring human assertion has been properly set.
        
        Args:
            field_name: Name of the field
            value: Value to validate
            
        Returns:
            True if valid, False otherwise
        """
        if field_name in AuthorityBoundary.HUMAN_REQUIRED_FIELDS:
            # Field must be explicitly set, not auto-generated
            if value is None or value == "":
                return False
            # Additional validation could check for metadata indicating human origin
            return True
        return True
    
    @staticmethod
    def is_protected_code(code: str) -> bool:
        """Check if a code is protected and requires human assignment."""
        return code in AuthorityBoundary.PROTECTED_CODES
    
    @staticmethod
    def can_auto_generate(field_path: str) -> bool:
        """Check if a field can be auto-generated by AI."""
        return field_path not in AuthorityBoundary.NO_AI_GENERATION
    
    @staticmethod
    def validate_evidence_reference(evidence_data: dict) -> bool:
        """
        Validate that evidence is referenced correctly (not embedded).
        
        Args:
            evidence_data: Evidence reference data
            
        Returns:
            True if valid reference, False if embedded data detected
        """
        # Must have ID and reference
        if "id" not in evidence_data or "nice_ref" not in evidence_data:
            return False
        
        # Must NOT contain embedded image data
        prohibited_keys = {"image_data", "base64", "binary", "blob"}
        if any(key in evidence_data for key in prohibited_keys):
            return False
        
        return True


class ValidationRules:
    """
    Validation rules for EICR data.
    """
    
    @staticmethod
    def validate_report_id(report_id: str) -> bool:
        """Validate report ID format: EICR-YYYY-NNN"""
        import re
        pattern = r"^EICR-\d{4}-\d{3}$"
        return bool(re.match(pattern, report_id))
    
    @staticmethod
    def validate_classification_code(code: str) -> bool:
        """Validate that classification code is valid."""
        try:
            ClassificationCode(code)
            return True
        except ValueError:
            return False
    
    @staticmethod
    def validate_overall_assessment(assessment: str) -> bool:
        """Validate overall assessment value."""
        try:
            OverallAssessment(assessment)
            return True
        except ValueError:
            return False
    
    @staticmethod
    def validate_observation(observation: dict) -> List[str]:
        """
        Validate an observation entry.
        
        Returns:
            List of validation errors (empty if valid)
        """
        errors = []
        
        # Required fields
        if "item" not in observation or not observation["item"]:
            errors.append("Observation must have an item reference")
        
        if "description" not in observation or not observation["description"]:
            errors.append("Observation must have a description")
        
        if "classification" not in observation:
            errors.append("Observation must have a classification code")
        elif not ValidationRules.validate_classification_code(observation["classification"]):
            errors.append(f"Invalid classification code: {observation['classification']}")
        
        # Validate evidence references
        if "evidence_refs" in observation:
            for i, evidence in enumerate(observation["evidence_refs"]):
                if not AuthorityBoundary.validate_evidence_reference(evidence):
                    errors.append(f"Invalid evidence reference at index {i}")
        
        return errors


class AuditTrail:
    """
    Audit trail requirements for EICR system.
    """
    
    REQUIRED_METADATA: Set[str] = {
        "created_by",
        "created_at",
        "modified_by",
        "modified_at",
        "assertion_source",  # 'human' or 'system'
    }
    
    @staticmethod
    def create_audit_entry(action: str, user: str, data: dict) -> dict:
        """
        Create an audit trail entry.
        
        Args:
            action: Action performed
            user: User who performed the action
            data: Data that was modified
            
        Returns:
            Audit entry
        """
        from datetime import datetime
        
        return {
            "action": action,
            "user": user,
            "timestamp": datetime.utcnow().isoformat(),
            "data_snapshot": data,
        }


# Export the contract classes
__all__ = [
    "ClassificationCode",
    "OverallAssessment",
    "AuthorityBoundary",
    "ValidationRules",
    "AuditTrail",
]
